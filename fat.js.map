{"version":3,"sources":["core.js","api.js","http.js","httpjson.js","websocket.js","url.js","router.js","template.js","urls.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"fat.js","sourcesContent":["const Fat = {\n    plugins:         new Map(),\n    config:          {},\n    signals:         new Map(),\n    configure:       function (options) {\n        Object.assign(this.config.modules, options.modules);\n        Object.assign(this.config.plugins, options.plugins);\n        delete options.modules;\n        delete options.plugins;\n        Object.assign(this.config, options);\n\n        for (var mod in this.config.modules){\n            Fat[mod].configure && Fat[mod].configure(this.config.modules[mod]);\n        }\n\n        if (jinja && this.config.template_url) {\n            jinja.template_url = this.config.template_url;\n        }\n    },\n    register_module: function (name, mod) {\n        Object.defineProperty(Fat, name, {value:new mod(Fat.config.modules[name]), writable:false});\n    },\n    register_plugin: function (name, plugin) {\n        if (typeof(plugin.init) != 'function') {\n            throw \"[\" + name + \"] bad plugin: no init\";\n        }\n        Fat.plugins.set(name, plugin);\n    },\n    setup_plugins:   function (plugin_names) {\n        if (typeof(plugin_names) == typeof(\"\")) {\n            plugin_names = [plugin_names];\n        }\n        for (var plugin of plugin_names) {\n            if (this.plugins.has(plugin)) {\n                var p = this.plugins.get(plugin);\n                p.init(Fat.config.plugins[plugin] || {});\n            }\n        }\n    }\n};\nObject.defineProperty(Fat.config,'plugins',{\n    writable:false,\n    value:{}\n});\nObject.defineProperty(Fat.config,'modules',{\n    writable:false,\n    value:{}\n});\nFat.fetch = function(url, options){\n    options = options || {};\n    return fetch(url, options).then(function(response){\n        // status \"0\" to handle local files fetching (e.g. Cordova/Phonegap etc.)\n        if (response.status === 200 || response.status === 0) {\n            return Promise.resolve(response)\n        } else {\n            return Promise.reject(new Error(response.statusText))\n        }\n    }).then(function(response){\n        // TODO: handle other fetch data types\n        if (options.type == 'json'){\n            return response.json();\n        } else {\n            return response.text();\n        }\n    });\n};\nFat.fetch_data = function (name) {\n    var url = Fat.config.static_url;\n    if (!url.endsWith('/')) {\n        url += '/';\n    }\n    url += 'data/' + name + '.json';\n    return Fat.fetch(url, {type:'json',headers:{'Accept':'application/json'}});\n};\nFat.add_listener = function (signal, handler, scope) {\n    if (!Fat.signals.has(signal)) {\n        Fat.signals.set(signal, new Map());\n    }\n    Fat.signals.get(signal).set(handler, scope);\n};\n\nFat.remove_listener = function (signal, handler) {\n    if (!Fat.signals.has(signal)) {\n        return;\n    }\n    Fat.signals.get(signal).delete(handler);\n    if (!Fat.signals.get(signal).size) {\n        Fat.signals.delete(signal);\n    }\n};\n\nFat.emit = function (signal, data) {\n    if (Fat.signals.has(signal)) {\n        var handler_map = Fat.signals.get(signal);\n        for (var entry of handler_map) {\n            entry[0].call(entry[1], data);\n        }\n    }\n};\n\n/*\n options framework\n\n find_domain(domainPath) {\n let keys = domainPath.split(\".\");\n let domain = this.config;\n while (keys.length > 1) {\n if (!domain.hasOwnProperty(keys[0])) {\n domain[keys[0]] = {};\n }\n domain = domain[keys[0]];\n keys.slice(1);\n }\n return domain;\n }\n\n get_option(domainPath, defaultVal = null) {\n let keys = domainPath.split(\".\");\n let domain = this.config;\n while (keys.length > 1) {\n if (!domain.hasOwnProperty(keys[0])) {\n return defaultVal;\n }\n domain = domain[keys[0]];\n keys.slice(1);\n }\n return domain[keys[0]];\n }\n\n set_option(domainPath, value = true) {\n let keys = domainPath.split(\".\");\n let keyToSet = keys[keys.length - 1];\n let domain = this.find_domain(keys.slice(0, keys.length - 1));\n domain[keyToSet] = value;\n }\n\n */\n\nwindow.Fat = Fat;\n","function API(options) {\n    this.options = options || {};\n    this.defaults = {\n        url:     window.location.pathname,\n        backend: 'httpjson'\n    };\n    this.options = Object.assign(this.defaults, this.options);\n}\nAPI.prototype.configure = function(options){\n    this.options = Object.assign(this.defaults, options || {});\n};\nAPI.prototype.backends = {};\nAPI.prototype.add_backend = function (name, backend) {\n    API.prototype.backends[name] = backend;\n};\nAPI.prototype.call = function (signature, args) {\n    return API.prototype.backends[this.options.backend].call(this.options.url, signature, args);\n};\n\nAPI.prototype.call_many = function (requests) {\n    return API.prototype.backends[this.options.backend].call_many(this.options.url, requests);\n};\nFat.register_module('api', API);\n","Fat.api.add_backend('http', {\n    call: function (url, signature, data) {\n        return Fat.fetch(url,{\n            method:\"POST\",\n            body: Fat.url.stringify({signature: signature, data: data}),\n            type:'json'\n        });\n    },\n    call_many: function (url, requests) {\n        return Fat.fetch(url,{\n            method:\"POST\",\n            body: Fat.url.stringify({requests: requests}),\n            type:'json'\n        });\n    }\n});\n","Fat.api.add_backend('httpjson', {\n    call: function (url, signature, data) {\n        return Fat.fetch(url,{\n            method:\"POST\",\n            body: JSON.stringify({signature: signature, data: data}),\n            type:'json'\n        });\n    },\n    call_many: function (url, requests) {\n        return Fat.fetch(url,{\n            method:\"POST\",\n            body: JSON.stringify({requests: requests}),\n            type:'json'\n        });\n    }\n});\n","!function () {\n    var seq = 0;\n    var state = null;\n    var ws = null;\n    var promises = {};\n    var queue = [];\n    var timeout = 100;\n\n    var init = function (url) {\n        ws = new WebSocket(url);\n        ws.onopen = function () {\n            state = 1;\n            console.debug('connected');\n            timeout = 100;\n            while (queue.length) {\n                send.apply(this, queue.splice(0, 1)[0]);\n            }\n        };\n        ws.onclose = function () {\n            state = null;\n            console.log('Соединение потеряно, восстанавливаем...');\n            setTimeout(function () {\n                timeout *= 2;\n                init(url);\n            }, timeout);\n        };\n        ws.onmessage = function (evt) {\n            var msg = JSON.parse(evt.data);\n            console.debug('RECV>', msg);\n            if (promises[msg.seq]) {\n                if (!msg.status) {\n                    promises[msg.seq].resolve(msg.data);\n                } else {\n                    promises[msg.seq].reject(msg.data);\n                }\n                delete promises[msg.seq];\n            }\n        };\n    };\n    var send = function (data, ready, options) {\n        promises[seq] = ready;\n        data.seq = seq;\n        if (options.gen_head) {\n            data.head = options.gen_head();\n        }\n        console.debug('SEND>', data);\n        ws.send(JSON.stringify(data));\n        seq++;\n    };\n    Fat.api.add_backend('ws', {\n        call: function (options, signature, data) {\n            var ready = new Promise();\n            if (!state) {\n                queue.push([\n                    {signature: signature, data: data},\n                    ready,\n                    options\n                ]);\n                init(options.url);\n            } else {\n                send({signature: signature, data: data}, ready, options);\n            }\n        },\n        call_many: function (options, requests) {\n            var ready = new Promise();\n            if (!state) {\n                queue.push([\n                    {requests: requests},\n                    ready,\n                    options\n                ]);\n                init(options.url);\n            } else {\n                send({requests: requests}, ready, options);\n            }\n        }\n    });\n}();\n","Fat.url = {\n    stringify:function(data, prefix = '') {\n        if (typeof(data) === typeof('')) {\n            return data;\n        }\n        var encoded = [];\n        var keyName;\n        var encoded_arg;\n        for (var key of Object.getOwnPropertyNames(data)) {\n            if (typeof(data[key]) !== typeof({})) {\n                encoded_arg = key + \"=\" + encodeURIComponent(data[key]);\n            } else {\n                keyName = encodeURIComponent(key);\n                if (prefix) {\n                    keyName = prefix + \"[\" + keyName + \"]\";\n                }\n                encoded_arg = Fat.url.stringify(data[key], keyName);\n            }\n            encoded.push(encoded_arg);\n        }\n        return encoded.join('&');\n    },\n\n    parse_key: function(key, object, value) {\n        var first_key = key.substr(0, key.indexOf('['));\n        if (!first_key) {\n            object[first_key] = value;\n            return;\n        }\n        object[first_key] = object[first_key] || {};\n        var key_rest = key.substr(first_key.length + 1);\n        parse_key(key_rest.substr(0, key_rest.indexOf(']')) + key_rest.substr(key_rest.indexOf(']') + 1), object[first_key], value);\n    },\n\n    parse: function(serialized) {\n        if (!serialized) {\n            return {};\n        }\n        var hashes = serialized.split('&');\n        var vars = {};\n        var key;\n        var val;\n        for (var i = 0, len = hashes.length; i < len; i++) {\n            [key, val] = decodeURIComponent(hashes[i]).split('=');\n            this.parse_key(key, vars, val);\n        }\n        return vars;\n    }\n};\n","!function () {\n    var url_patterns = {};\n\n    function replace_placeholders(match, args) {\n        if (!args) {\n            return;\n        }\n        var match_place;\n        for (var i = 0, keys = Object.keys(args), len = keys.length; i < len; i++) {\n            var arg = keys[i];\n            if (typeof args[arg] === 'object') {\n                replace_placeholders(match, args[arg]);\n            } else if (typeof args[arg] === 'string') {\n                match_place = args[arg].match(new RegExp('\\\\$(\\\\d+)', ''));\n                if (match_place) {\n                    args[arg] = match[Number(match_place[1])];\n                }\n            }\n        }\n    }\n\n    function find_match(url, prefix, patterns, matches) {\n        var match;\n        if (!matches) {\n            matches = [];\n        }\n        for (var pattern in patterns) {\n            match = url.match(new RegExp(prefix + pattern, ''));\n            if (match) {\n                if (patterns[pattern].patterns) {\n                    return find_match(url, prefix + pattern, patterns[pattern].patterns, matches);\n                } else {\n                    var res = Object.assign({}, patterns[pattern]);\n                    res.pattern = pattern;\n                    res.url = url;\n                    //replace_placeholders(match, actionInfo.args);\n                    //return actionInfo;\n                    return res;\n                }\n            }\n        }\n        return null;\n    }\n\n    Fat.router = {\n        resolve: function (url, patterns) {\n            if (!patterns) {\n                return find_match(url, '', url_patterns);\n            } else {\n                return find_match(url, '', patterns);\n            }\n        },\n        patterns: function (patterns) {\n            Object.assign(url_patterns, patterns);\n        }\n    };\n}();\n","Fat.render = function ($elements, template, data) {\n    return new Promise(function (resolve, reject) {\n        jinja.render('{% include \"' + template + '\" %}', data).then(function (html) {\n            // TODO: mb make sure elements are empty\n            for (var i = 0; i < $elements.length; i++) {\n                $elements[i].innerHTML = html;\n            }\n            resolve();\n        });\n    });\n}\n","!function(){\n    const reverse={};\n    const urls = {};\n\n    Fat.urls=function urls(urls){\n\n    };\n\n    function make_reverse(){}\n    make_reverse();\n\n    jinja.make_tag('url',function(stmt){\n        var tokens=stmt.split(' ');\n        var url = tokens[0].substr(1,tokens[0].length-2);\n\n        var open = url.indexOf('(');\n        var close = -1;\n        var url_part;\n        if (open) {\n            url_part = url.substr(close+1, open-close-1);\n            this.push(url_part);\n            close = url.indexOf(')');\n            for (var i = 1; i < tokens.length; i++) {\n                this.push('get(' + tokens[i] + ')');\n                open = url.indexOf('(', close+1);\n                if (open > 0) {\n                    url_part = url.substr(close+1, open-close-1);\n                    this.push(url_part);\n                    close = url.indexOf(')');\n                }\n            }\n            url_part = url.substr(close+1, url.length-close-1);\n        } else {\n            url_part = url;\n        }\n        this.push(url_part);\n    });\n\n    jinja.make_tag('static',function(stmt){\n        stmt = stmt.trim();\n        this.push(\"write(\\\"\"+Fat.config.static_url + stmt.substr(1,stmt.length-2)+\"\\\")\");\n    });\n}();\n"],"sourceRoot":"/source/"}