// Generated by CoffeeScript 1.7.1
(function() {
  var addConnection, invoke, parseSignal, registeredBuses, removeConnection, signalModifiers, validateSignal, __connectionTable,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  registeredBuses = {};

  self.IBus = (function() {
    function IBus() {
      var errors;
      errors = '';
      if (!this.hasOwnProperty('sighandler')) {
        errors += 'sighandler property unimplemented!\n';
      }
      if (!this.hasOwnProperty('setupConnection')) {
        errors += 'setupConnection property unimplemented!\n';
      }
    }

    IBus.prototype.setupConnection = function() {};

    IBus.prototype.sighandler = function(signal) {};

    return IBus;

  })();

  self.registerBus = function(name, oBus) {
    return registeredBuses[name] = oBus;
  };

  self.getBus = function(name) {
    return registeredBuses[name];
  };


  /*
      СИГНАЛЫ
  
      Именование:
          sigName ::= [typeDescriptor] [a-zA-Z._]+
          typeDescriptor ::= [=]{,1}
      Типы:
      sigName - простой сигнал, отправляется на локальные объекты, подписка является постоянной
      =sigName - временный сигнал. отправляется на локальные объекты, подписка уничтожается после вызова
      * - любой сигнал
   */

  signalModifiers = ['=', '*'];

  parseSignal = function(sSignal) {
    var emitter, modifier, name, signal, _ref, _ref1;
    _ref = sSignal.split(':'), signal = _ref[0], emitter = _ref[1];
    name = signal.replace(new RegExp('[' + signalModifiers.join('') + ']'), '');
    modifier = (_ref1 = signal[0], __indexOf.call(signalModifiers, _ref1) >= 0) ? signal[0] : '';
    return {
      name: name,
      emitter: emitter,
      modifier: modifier
    };
  };

  validateSignal = function(sSignal) {
    if (sSignal !== '*') {
      if (!(sSignal.match('^[' + signalModifiers.join('') + ']?[a-zA-Z][a-zA-Z_.0-9]*$'))) {
        throw 'Bad signal name: ' + sSignal;
      }
    }
  };

  __connectionTable = {};

  addConnection = function(sSignal, sSlot, oReceiver, fSlot) {
    var objectName;
    objectName = oReceiver.__id__;
    if (__connectionTable[sSignal] == null) {
      __connectionTable[sSignal] = {};
    }
    if (__connectionTable[sSignal][objectName] == null) {
      __connectionTable[sSignal][objectName] = {
        instance: oReceiver,
        slots: {}
      };
    }
    if (fSlot) {
      __connectionTable[sSignal][objectName].slots[sSlot] = fSlot;
    } else {
      __connectionTable[sSignal][objectName].slots[sSlot] = oReceiver[sSlot];
    }
    return sSlot;
  };

  removeConnection = function(sSignal, sSlot, oReceiver) {
    var objectName, sig, _ref, _ref1, _ref2, _ref3;
    objectName = oReceiver.__id__;
    if (sSignal === '*') {
      for (sig in __connectionTable) {
        if ((_ref = __connectionTable[sig]) != null ? _ref : [objectName] != null) {
          delete __connectionTable[sig][objectName];
        }
      }
      return;
    }
    if ((_ref1 = __connectionTable[sSignal]) != null ? (_ref2 = _ref1[objectName]) != null ? (_ref3 = _ref2.slots) != null ? _ref3[sSlot] : void 0 : void 0 : void 0) {
      delete __connectionTable[sSignal][objectName].slots[sSlot];
    } else {
      return;
    }
    if (Object.keys(__connectionTable[sSignal][objectName].slots).length === 0) {
      delete __connectionTable[sSignal][objectName];
      if (Object.keys(__connectionTable[sSignal]).length === 0) {
        return delete __connectionTable[sSignal];
      }
    }
  };

  invoke = function(sSignal, oData, emitResult) {
    var invokeSlots, sigData, temporary;
    if (oData == null) {
      oData = {};
    }
    if (emitResult == null) {
      emitResult = false;
    }
    sigData = parseSignal(sSignal);
    temporary = sigData.modifier === '=';
    invokeSlots = function(connectionList) {
      var appName, connectionInfo, name, res, slot, slotName, _ref;
      for (appName in connectionList) {
        connectionInfo = connectionList[appName];
        _ref = connectionInfo.slots;
        for (slotName in _ref) {
          slot = _ref[slotName];
          name = connectionInfo.instance.__app__ ? connectionInfo.instance.__app__ + '.' + connectionInfo.instance.__name__ : connectionInfo.instance.toString();
          oData.__signal__ = sigData.name;
          res = slot.call(connectionInfo.instance, oData, sigData.emitter);
          if (sigData.emitter && emitResult && res !== null) {
            EMIT('=' + sigData.name, res, sigData.emitter);
          }
          if (temporary) {
            removeConnection('=' + sigData.name + (sigData.emitter ? ':' + sigData.emitter : ''), slotName, connectionInfo.instance);
          }
        }
      }
    };
    if (__connectionTable[sSignal]) {
      return invokeSlots(__connectionTable[sSignal]);
    } else if (__connectionTable[sigData.modifier + sigData.name]) {
      return invokeSlots(__connectionTable[sigData.modifier + sigData.name]);
    }
  };

  self.DISCONNECT = function(sSignal, sSlot, oReceiver, UID) {
    if (UID == null) {
      UID = null;
    }
    validateSignal(sSignal);
    if (UID) {
      sSignal += ':' + UID;
    }
    return removeConnection(sSignal, sSlot, oReceiver);
  };

  self.CONNECT = function(sSignal, sSlot, oReceiver, UID) {
    var fSlot;
    if (UID == null) {
      UID = null;
    }
    validateSignal(sSignal);
    if (UID) {
      sSignal += ':' + UID;
    }
    if (typeof sSlot === typeof (function() {})) {
      fSlot = sSlot;
      sSlot = inSide.__nextID();
    } else {
      if (oReceiver[sSlot] == null) {
        console.log('failed to connect: ' + sSignal + ' -> ' + sSlot);
        throw "No such slot: " + sSlot;
      }
    }
    return addConnection(sSignal, sSlot, oReceiver, fSlot);
  };

  self.EMIT = function(sSignal, oArgs, oSender, emitResult) {
    var bus, busName, _results;
    if (oSender == null) {
      oSender = null;
    }
    if (emitResult == null) {
      emitResult = false;
    }
    validateSignal(sSignal);
    if (oSender) {
      sSignal = sSignal + ':' + (oSender.__id__ != null ? oSender.__id__ : oSender.toString());
    }
    invoke(sSignal, oArgs, emitResult);
    _results = [];
    for (busName in registeredBuses) {
      bus = registeredBuses[busName];
      _results.push(bus.sighandler({
        type: 'signal',
        signal: sSignal,
        data: oArgs,
        sender: oSender
      }));
    }
    return _results;
  };

  self.EMIT_AND_WAIT = function(oSender, sSignal, oArgs, sSlot) {
    sSignal.replace('=', '');
    validateSignal(sSignal);
    CONNECT('=' + sSignal, sSlot, oSender, oSender.__id__);
    return EMIT(sSignal, oArgs, oSender, true);
  };

  self.INIT_CONNECTIONS = function(scope, oConnections) {
    var handler, signal, _results;
    _results = [];
    for (signal in oConnections) {
      handler = oConnections[signal];
      _results.push(CONNECT(signal, handler, scope));
    }
    return _results;
  };

}).call(this);
