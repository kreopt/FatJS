// Generated by CoffeeScript 1.3.1
(function() {
  var Lexer, Parser, T, blockTags, g, keywords, kw, tagGram, tokens;

  keywords = {
    foreach: 'foreach',
    "for": 'for',
    "if": 'if',
    "else": 'else',
    elif: 'elif',
    "in": 'in',
    as: 'as',
    "while": 'while',
    section: 'section',
    loop: 'loop',
    cdata: 'literal',
    block: 'block',
    include: 'include',
    "extends": 'extends'
  };

  kw = keywords;

  blockTags = [kw.foreach, kw["for"], kw["while"], kw.section, kw.cdata, kw.block, kw["if"]];

  /*
      NON-STANDARD OPERATORS:
      $a**$b - b degree of a
      $a#$b - concatenate
      $a? - existance
  */


  tokens = {
    IDENTIFIER: /\$[A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*/,
    NUMBER: /[0-9]+/,
    STRING: /"[^"]*"|'[^']*'/,
    BINOPERATOR: /\+|-|\*|\/|%|\||^|&|=|\+=|-=|\*=|\/=|%=|\|=|&=|^=|&&|\|\||>>|<<|>>>|\*\*|#/,
    PREOPERATOR: /\+\+|--|-|~|!/,
    POSTOPERATOR: /\+\+|--|\?/
  };

  T = tokens;

  g = function(gram) {
    return function() {
      return tagGram(gram);
    };
  };

  tagGram = {
    expression: [[T.IDENTIFIER], [T.NUMBER], [g('expression', T.BINOPERATOR, g('expression'))], [T.PREOPERATOR, g('expression')], [g('expression', T.POSTOPERATOR)]],
    body: [[g('line')], [g('block')]],
    line: [[''], [g('expression')], [g('expression', ';', g('line'))]],
    block: [[g('foreach')]],
    foreach: [['foreach', T.IDENTIFIER, 'as', T.IDENTIFIER], ['foreach', T.IDENTIFIER, 'as', T.IDENTIFIER, '=>', T.IDENTIFIER]]
  };

  Lexer = (function() {

    function Lexer() {}

    Lexer.prototype.findToken = function(sString) {};

    return Lexer;

  })();

  Parser = (function() {

    Parser.prototype.parseStack = {
      type: 'root',
      node: []
    };

    Parser.prototype.varTypes = {};

    Parser.prototype.stacksStack = [];

    function Parser() {
      this.stacksStack[0] = this.parseStack.node;
      Object.defineProperty(this, 'stack', {
        get: function() {
          return this.stacksStack[this.stacksStack.length - 1];
        }
      });
    }

    Parser.prototype.popStack = function() {
      return this.stacksStack.pop();
    };

    Parser.prototype.pushStack = function(aNodeStack) {
      return this.stacksStack.push(aNodeStack);
    };

    Parser.prototype.parse = function(sTplString) {
      var prefix, tag, _ref;
      while (sTplString) {
        _ref = this.findTag(sTplString), prefix = _ref[0], tag = _ref[1], sTplString = _ref[2];
        if (prefix) {
          this.stack.push(prefix);
        }
        this.stack.push(this.parseTag(tag));
      }
      return parseStack;
    };

    Parser.prototype.findTag = function(sTplString) {
      var endIndex, postfix, prefix, startIndex, tag;
      startIndex = sTplString.indexOf('{');
      endIndex = sTplString.indexOf('}');
      if (endIndex < startIndex) {
        throw 'unmatched } near "...' + sTplString.substr((endIndex >= 10 ? endIndex - 10 : 0), 20) + '..."';
      }
      prefix = sTplString.substr(0, startIndex);
      tag = sTplString.substr(startIndex + 1, endIndex - startIndex - 1);
      postfix = sTplString.slice(endIndex + 1);
      return [prefix, tag, postfix];
    };

    Parser.prototype.parseTag = function(sTagStr) {
      var isBlockTag, isOpenTag;
      isBlockTag = false;
      if (isBlockTag) {
        isOpenTag = true;
        switch (isOpenTag) {
          case true:
            this.pushStack(node.node);
            break;
          case false:
            this.popStack();
        }
      } else {

      }
      return node;
    };

    return Parser;

  })();

  window.Parser = new Parser();

}).call(this);
