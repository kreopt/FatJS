// Generated by CoffeeScript 1.3.1

/*
    NON-STANDARD OPERATORS:
    $a**$b - b degree of a
    $a#$b - concatenate
    $a? - existance
*/


(function() {
  var Parser, T, blockTags, endblockTags, g, tagGram, tokens,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  tokens = {
    FOREACH: [/^foreach/],
    FOR: [/^for/],
    WHILE: [/^while/],
    SECTION: [/^section/],
    CDATA: [/^literal/],
    BLOCK: [/^block/],
    IF: [/^if/],
    ENDFOREACH: [/^\/foreach/],
    ENDFOR: [/^\/for/],
    ENDWHILE: [/^\/while/],
    ENDSECTION: [/^\/section/],
    ENDCDATA: [/^\/literal/],
    ENDBLOCK: [/^\/block/],
    ENDIF: [/^\/if/],
    ELSE: [/^else/],
    ELIF: [/^elif/],
    IN: [/^in/],
    AS: [/^as/],
    LOOP: [/^loop/],
    INCLUDE: [/^include/],
    EXTENDS: [/^extends/],
    IDENTIFIER: [
      /^\$[A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*/, function(parser, token) {
        return parser.vars[token] = null;
      }
    ],
    NUMBER: [/^[0-9]+/],
    STRING: [/^"[^"]*"|'[^']*'/],
    OPERATION: [/^\=\=|!=|<|>|>=|>=|!==|===/],
    BINOPERATOR: [/^\+|-|\*|\/|%|\||\^|\&|=|\+=|-=|\*=|\/=|%=|\|=|\&=|\^=|\&\&|\|\||>>|<<|>>>|\*\*|\#/],
    PREOPERATOR: [/^\+\+|--|-|~|!/],
    POSTOPERATOR: [/^\+\+|--|\?/],
    ARRAYBEGIN: [/^\[/, function(parser) {}],
    ARRAYEND: [/^\]/, function(parser) {}],
    COMMA: [/^,/],
    DOT: [/^\./]
  };

  T = tokens;

  blockTags = ['FOREACH', 'FOR', 'WHILE', 'SECTION', 'CDATA', 'BLOCK', 'IF'];

  endblockTags = ['ENDFOREACH', 'ENDFOR', 'ENDWHILE', 'ENDSECTION', 'ENDCDATA', 'ENDBLOCK', 'ENDIF'];

  g = function(gram) {
    return function() {
      return tagGram(gram);
    };
  };

  tagGram = {
    expression: [[T.IDENTIFIER], [T.NUMBER], [g('expression', T.BINOPERATOR, g('expression'))], [g('expression', T.OPERATION, g('expression'))], [T.PREOPERATOR, g('expression')], [g('expression', T.POSTOPERATOR)]],
    body: [[g('line')], [g('block')]],
    line: [[''], [g('expression')], [g('expression', ';', g('line'))]],
    block: [[g('foreach')]],
    foreach: [['foreach', T.IDENTIFIER, 'as', T.IDENTIFIER], ['foreach', T.IDENTIFIER, 'as', T.IDENTIFIER, '=>', T.IDENTIFIER]]
  };

  Parser = (function() {

    function Parser() {
      Object.defineProperty(this, 'stack', {
        get: function() {
          return this.stacksStack[this.stacksStack.length - 1].node;
        }
      });
      Object.defineProperty(this, 'stacktype', {
        get: function() {
          return this.stacksStack[this.stacksStack.length - 1].type;
        }
      });
    }

    Parser.prototype.popStack = function() {
      return this.stacksStack.pop();
    };

    Parser.prototype.pushStack = function(oNode) {
      return this.stacksStack.push(oNode);
    };

    Parser.prototype.parse = function(sTplString) {
      var link, node, prefix, tag, tagNumber, tagTokens, _ref, _ref1, _ref2,
        _this = this;
      this.vars = {};
      this["const"] = {};
      this.parseStack = {
        type: 'ROOT',
        node: []
      };
      this.stacksStack = [this.parseStack];
      this.lineNumber = 1;
      tagNumber = 0;
      while (sTplString) {
        _ref = this.findTag(sTplString), prefix = _ref[0], tag = _ref[1], sTplString = _ref[2];
        link = function(node) {
          if (_this.stack[_this.stack.length - 1]) {
            node.prev = _this.stack[_this.stack.length - 1];
            _this.stack[_this.stack.length - 1].next = node;
          }
          node.next = null;
          return node.tag = tagNumber;
        };
        if (prefix) {
          node = {
            type: 'TEXT',
            value: prefix
          };
          link(node);
          this.stack.push(node);
        }
        tagTokens = this.parseTag(tag);
        if (!tagTokens.length) {
          continue;
        }
        if (_ref1 = tagTokens[0][0], __indexOf.call(blockTags, _ref1) >= 0) {
          node = {
            type: tagTokens[0][0],
            node: []
          };
          link(node);
          this.stack.push(node);
          this.pushStack(node);
        } else if (_ref2 = tagTokens[0][0], __indexOf.call(endblockTags, _ref2) >= 0) {
          if (this.stacktype === tagTokens[0][0].replace(/^END/, '')) {
            this.popStack();
          } else {
            throw this.lineNumber + ': Unmatched close tag "' + tagTokens[0][0] + '"';
          }
        } else {
          tagTokens.map(function(node) {
            node = {
              type: node[0],
              value: node[2]
            };
            link(node);
            return _this.stack.push(node);
          });
        }
        tagNumber++;
      }
      return this.parseStack;
    };

    Parser.prototype.findTag = function(sTplString) {
      var endIndex, lineBreakIndex, startIndex;
      startIndex = sTplString.indexOf('{');
      if (startIndex === -1) {
        return [sTplString, '', ''];
      }
      endIndex = sTplString.indexOf('}');
      lineBreakIndex = sTplString.indexOf('\n');
      while (lineBreakIndex >= 0 && lineBreakIndex < endIndex) {
        lineBreakIndex = sTplString.indexOf('\n', lineBreakIndex + 1);
        this.lineNumber++;
      }
      if (endIndex < startIndex) {
        throw this.lineNumber + ': Unmatched } near "...' + sTplString.substr((endIndex >= 10 ? endIndex - 10 : 0), 20) + '..."';
      }
      return [sTplString.substr(0, startIndex), sTplString.substr(startIndex + 1, endIndex - startIndex - 1), sTplString.slice(endIndex + 1)];
    };

    Parser.prototype.nextToken = function(sTagStr) {
      var match, tokenName, tokenRE;
      if (sTagStr.match(/^\s*$/)) {
        return null;
      }
      if (match = sTagStr.match(/^\s+/)) {
        return [null, match[0].length, match[0]];
      }
      for (tokenName in tokens) {
        tokenRE = tokens[tokenName];
        if (match = sTagStr.match(tokenRE[0])) {
          if (tokenRE[1]) {
            tokenRE[1](this, match[0]);
          }
          return [tokenName, match[0].length, match[0]];
        }
      }
      throw this.lineNumber + ': No match for token "' + sTagStr + '"';
    };

    Parser.prototype.parseTag = function(sTagStr) {
      var tagTokens, token;
      tagTokens = [];
      token = this.nextToken(sTagStr);
      while (token !== null) {
        tagTokens.push(token);
        if (token[0]) {
          token;

        }
        sTagStr = sTagStr.substr(token[1]);
        token = this.nextToken(sTagStr);
      }
      return tagTokens;
    };

    return Parser;

  })();

  window.Parser = new Parser();

}).call(this);
